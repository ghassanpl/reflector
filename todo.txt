- make sure we're ensuring field `CleanName`s are unique

- see if we can't change this:
		RClass(Abstract, CreateIsChilds=[Door,Decoration,Item,Enemy,Hero,Creature]);
into
		[[RClass(Abstract, CreateIsChilds=[Door,Decoration,Item,Enemy,Hero,Creature])]] 

- we should unify and simplify error reporting

- we COULD, if we're still using RMethod macros, add [[nodiscard]] by default to all methods

- since we're using `header_utils` anyway, might as well use Assuming

- support '{' on enum primary declaration line (`enum blah {`)

- check if we can use __COUNTER__ instead of __LINE__ in RBody() macros (will make it so that intellisense only fails when order of classes is changed, not the line their body is at)

- support C++ attributes (nodiscard, noreturn, deprecated)

- add Resolvable?

- ability to clone objects?

- ability to have garbage-collection for classes deriving from Reflectable
	- we would need to mark containers and other such fields

- RConstructor() ?
- RUsing(); - for commenting `using X = ...;` declarations, so that generated documentation is better (probably other things too)
- RConstant(); - for constexprs
- ROperator();
- RNamespace() ?
- RTest() ? - for marking static methods as tests
- RVersion() ? - or should we get that information from, in order: git tags, git commit, datetime
- RContext() ?

- check if we can't do something like:

struct MaxAttribute { int Value; };
...
RField(CustomAttributes = { Max = 5 })

that turns into

REFL_VISITOR(..., ..., CompileTimeFieldData<..., MaxAttribute{5}>{});

and adds that MaxAttribute to a `std::vector<std::any> CustomAttributes;` that's in the runtime class reflection data