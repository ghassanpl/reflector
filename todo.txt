- ability to run reflected program in "docmode", that is, running special Reflector-generated methods to generate its own 
documentation pages based on its own criteria

- see if we can't change this:
		RClass(Abstract, CreateIsChilds=[Door,Decoration,Item,Enemy,Hero,Creature]);
into
		[[RClass(Abstract, CreateIsChilds=[Door,Decoration,Item,Enemy,Hero,Creature])]] 
	- we could, but:
		- RBody(); would have to stay the same
		- REnum(); would probably have to stay (though we could definitely use a magic_enum-style method reflection system)
		- this would require users to disable warnings on unrecognized attributes
	- maybe as an option?

- ability to deep-clone objects?

- RConstructor() ?
- RAlias()/RUsing(); - for commenting `using X = ...;` declarations, so that generated documentation is better (probably other things too)
- RConstant(); - for constexprs
- ROperator();
- RNamespace() ?
- RTest() ? - for marking static methods as tests
- RVersion() ? - or should we get that information from, in order: git tags, git commit, datetime
- RContext() ?
- RDoc();

- check if we can't do something like:

struct MaxAttribute { int Value; };
...
RField(CustomAttributes = { Max = 5 })

that turns into

REFL_VISITOR(..., ..., CompileTimeFieldData<..., MaxAttribute{5}>{});

and adds that MaxAttribute to a `std::vector<json> CustomAttributes;` that's in the runtime class reflection data