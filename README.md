# reflector

## Example

This file (`Component.h`):

```c++
#include "Component.mirror.h" /// This .mirror.h file will be autogenerated and placed next to its corresponding Component.h file

namespace Ass /// Namespaces are ignored right now
{
	/// Classes are declared like this. Right now they have to derive (at some point) from Reflector::Reflectable.
	/// Support for "structs", reflected classes with no bases, is coming.
	RClass({"Category": "Components", "Icon": "ICON_FA_CUBE"})
	class Component : public Reflector::Reflectable
	{
		/// Classes need to have this macro at the beginning. It automatically sets the following members to `public:`.
		RBody()

		/// Fields are declared like this. All reflected entities can have properties. These can be queried at runtime. Compile-time property queries
		/// would also be possible, but are not available right now. Properties are stored as JSON strings, and, if nlohmann/json is included, as nlohmann::json values.
		/// Some properties modify the behavior of the Reflector, e.g. generate getters/setters.
		RField({"ReadOnly": true, "Required": true, "Setter": false})
		std::string Name;

		/// Methods are declared like this. They have to have trailing return types at the moment. This will change in the future, at least
		/// for simple types.
		RMethod()
		auto SetName(std::string_view name) -> void;

		/// Methods can be virtual, and can have inline bodies. Right now there is support for generating "binding" methods (for scripting languages
		/// like Lua, etc.) - static functions with a common signature that call the reflected method.
		RMethod()
		virtual auto OnLoadRequested() -> void
		{
			LoadResources();
		}
		
	protected:

		virtual void LoadResources() {}
		
		virtual void Instantiate() {}

		/// Fields and methods can be of any access level. Comments that start with '///' like this one will be included
		/// in the reflection data.
		RField({"ParentPointer": true})
		class Object* mParentObject = nullptr;
	};

	/// Enums can also be reflected.
	/// Right now, only enum classes are supported.
	/// Enumerators can have initializers, but only integer literal initializers are supported right now.
	REnum()
	enum class TestEnum
	{
		A = 5,
		B,
		C
	};
}
```

will be internally turned into this:

```c++
namespace Ass
{
	class Component : public Reflector::Reflectable
	{
	public:
		typedef Component self_type; 
		typedef Reflector::Reflectable parent_type; 
		using parent_type::parent_type; 
		Component() : Reflector::Reflectable(StaticGetReflectionData()) {} 
		Component(::Reflector::ClassReflectionData const& klass) : Reflector::Reflectable(klass) {} 
		
		static ::Reflector::ClassReflectionData const& StaticGetReflectionData() { 
			static const ::Reflector::ClassReflectionData _data = { 
				.Name = "Component", 
				.ParentClassName = "Reflectable", 
				.Properties = R"_REFLECT_({"Category":"Components","Icon":"ICON_FA_CUBE"})_REFLECT_", 
				.Constructor = +[](const ::Reflector::ClassReflectionData& klass){ return (void*)new self_type{klass}; }, 
				.Fields = { 
					::Reflector::FieldReflectionData { 
						.Name = "Name", 
						.FieldType = "std::string", 
						.Properties = R"_REFLECT_({"ReadOnly":true,"Required":true,"Setter":false})_REFLECT_", 
						.FieldTypeIndex = typeid(std::string) 
					}, 
					::Reflector::FieldReflectionData { 
						.Name = "mParentObject", 
						.FieldType = "class Object*", 
						.Properties = R"_REFLECT_({"ParentPointer":true})_REFLECT_", 
						.FieldTypeIndex = typeid(class Object*) 
					}, 
				}, 
				.Methods = { 
					::Reflector::MethodReflectionData { 
						.Name = "SetName", 
						.ReturnType = "void", 
						.Parameters = "std::string_view name", 
						.ReturnTypeIndex = typeid(void), 
						.ParentClass = &_data 
					}, 
					::Reflector::MethodReflectionData { 
						.Name = "OnLoadRequested", 
						.ReturnType = "void", 
						.ReturnTypeIndex = typeid(void), 
						.ParentClass = &_data 
					}, 
				}, 
				.TypeIndex = typeid(self_type) 
			}; 
			return _data; 
		} 
		
		virtual ::Reflector::ClassReflectionData const& GetReflectionData() const override { return StaticGetReflectionData(); } 
		
		template <typename VISITOR> 
		static void StaticVisitMethods(VISITOR&& visitor) { 
			visitor(&Component::StaticGetReflectionData().Methods[0], &Component::SetName, &Component::ScriptFunction_SetName); 
			visitor(&Component::StaticGetReflectionData().Methods[1], &Component::OnLoadRequested, &Component::ScriptFunction_OnLoadRequested);; 
		} 
		
		template <typename VISITOR> 
		static void StaticVisitFields(VISITOR&& visitor) { 
			visitor(&Component::StaticGetReflectionData().Fields[0], &Component::Name, std::true_type{}); 
			visitor(&Component::StaticGetReflectionData().Fields[1], &Component::mParentObject, std::false_type{});; 
		} 
		
		static int ScriptFunction_SetName(struct lua_State* thread) { return 0; } 
		static int ScriptFunction_OnLoadRequested(struct lua_State* thread) { return 0; } 
	
	public:
	
		std::string Name;
	
		auto SetName(std::string_view name) -> void;
	
		virtual auto OnLoadRequested() -> void
		{
			LoadResources();
		}
	
	protected:
	
		virtual void LoadResources() {}
	
		virtual void Instantiate() {}
	
		class Object* mParentObject = nullptr;
	};
	
	enum class TestEnum;
	inline ::Reflector::EnumReflectionData const& StaticGetReflectionData(TestEnum) { 
		static const ::Reflector::EnumReflectionData _data = { 
			.Name = "TestEnum", 
			.Enumerators = { 
				::Reflector::EnumeratorReflectionData { 
					.Name = "A", 
					.Value = 5 
				}, 
				::Reflector::EnumeratorReflectionData { 
					.Name = "B", 
					.Value = 6 
				}, 
				::Reflector::EnumeratorReflectionData { 
					.Name = "C", 
					.Value = 7 
				}, 
			}, 
			.TypeIndex = typeid(TestEnum) 
		}; 
		return _data;
	}
		
	inline std::string_view GetEnumName(TestEnum) { return "TestEnum"; }
		
	inline std::string_view GetEnumeratorName(TestEnum v) { 
		switch (int64_t(v)) { 
			case 5: return "A"; 
			case 6: return "B"; 
			case 7: return "C"; 
			default: return "<Unknown>"; 
		} 
	}
	
	inline std::ostream& operator<<(std::ostream& strm, TestEnum v) { strm << GetEnumeratorName(v); return strm; }
	
	enum class TestEnum
	{
		A = 5,
		B,
		C
	};
}
```

## Dependencies

* C++17 (C++20 even)
* [nlohmann/json](https://github.com/nlohmann/json/)
* [args](https://github.com/Taywee/args)
* my personal [baselib](https://github.com/ghassanpl/baselib)

## Usage

	Reflector.exe files... {OPTIONS}
	OPTIONS:
			Commands
			-h, --help           Show help
			-r, --recursive      Recursively search the provided directories for files
			-q, --quiet          Don't print out created file names
			-f, --force          Ignore timestamps, regenerate all files
			-v, --verbose        Print additional information
			-j, --json           Output code that uses nlohmann::json to store class properties
			-d, --database       Create a JSON database with reflection data
			files...             Files or directories to scan
			"--" can be used to terminate flag options and force all following arguments to be treated as positional options
