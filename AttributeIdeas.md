# Ideas for Attributes

### Misc

```c++
StringAttribute Setter{ "Setter" /* "SetterName" ? */, "Only valid on Flag enums, will change the setter for this flag (if one is created) to this value", Targets::Enumerators};
StringAttribute TypeList{ "TypeList", "If set to an (reflected) enum name, creates IsX() { this->field == (decltype(this->field))N; } functions for each enumerator in the enum", Targets::Fields };
StringAttribute CreateIsChilds{ "CreateIsChilds", "Creates functions IsX (and AsX equivalents) for each subclass of this class in the given list, that checks if this object is of subclass X", Targets::Classes };
StringAttribute ScriptAccess{ "ScriptAccess", "Whether or not to hook up the generated accessors (getter, setter) to the scripting system", Targets::Fields, true };
```

Look at https://benui.ca/unreal/ufunction/ and others for ideas

* [record] **Save/Load=Custom** - do not automatically create JSONSaveFields, etc.
* [record] **AtomicSave** - always save all fields if any are not default
* [field] **Save/Load="<code>"** - insert `<code>` instead of using default serialization

* [private fields] **Mutex=mutexname** - Access to this field (via the accessors) is protected via a (optionally autogenerated) mutex `mutexname`
* [field] **Clone/View/Debug/Reset=false**
* [any?] **Category="Name"**
* [field] **Serialize=Custom** - calls a custom function to (de)serialize the field, instead of using the default json->get_to call
* [record] **GenerateResetFunctions** - will generate a Reset*FieldName* for each field in the class (see below), unless it has the Reset = false attribute
* [field] **Reset/Resettable** - will generate a Reset[FieldName] function that sets the field value to its initial value); having any of these in a class will create a Reset() function that resets every field
* [static field] **Config** - like Unreal's config, but, y'know, for statics
* [record] **Icon** - for the editors and such
* [any] **Internal** - do not document, what else? if nothing else, it's handled by `Document`
* [field] **Delegate** - creates Is*FieldName*Set() and Call*FieldName*() script-callable functions that check for std::function assignment and (optionally) call it  
	*Not sure if this is necessary, or it should be handled by the field type itself*
* [field] **Optional** - requires an optional type (like std::optional); will create Is#field_name and Reset#field_name in addition to regular accessors  
	*Not sure if this is necessary, optional already has a nice api of its own*
* [field] **ExposeMethods**=[names,of,methods] - will create `template <typename... ARGS> auto method_name(ARGS&&... args) { return field_name.method_name(std::forward<ARGS>(args)...); }`
		Or better yet, RField(ExposeMethods={GetSpeed=GetAnimationSpeed, ...}) Animation mAnimation;
* [record/field] **CustomEditor**=funcname
* [numeric field] **Min/Max/Step** - how to handle?
		* **NotEmpty** - for string/container fields
		* **ForceConstraints** - will clamp the input value in the setter
		* How would this work with validation/serialization?
* [integer field] **SelectFrom=FieldName** - the only valid values will be the keys of field FieldName
* [any] **Plural/Singular** - whether to create Is or Are prefixes and such;   
	*NOTE: Give example or where this could be useful*
* [record] **DefaultMethodAttributes** = {}
* [record] **DefaultFieldAttributes** = {}
* [enum] **DefaultEnumeratorAttributes** = {}
* [enum] **CreateVariant** - creates a std::variant<> type with types for each of the enumerator
	* [enumerator] **VariantType**="std::string" - only valid in CreateVariant enums, this enumerator will represent the given type
* [field] **Clone=false/Deep/Shallow** - when cloning the parent object, how should we clone the object pointed to by this field 
* [enum field] **OnlyNamed=true/false**

### Editing

All of these should probably be in an `Editor={ ... }` object

* [field] **ReadOnly** - not editable in editor, but visible
* [field] **Inline** - fields of this object will be editable inline
* [method] **Action** - adds a button control that calls this method
* [numeric field] **Chooser = Spin|DragBar|Dropdown**
* [string field] **Multiline=true|<integer max row count>**
* [field or category] **VisibleIf/EnabledIf=<code>** - hide/disable the field or category in the editor if the given code resolves false 

### Pre/Post/Validation
* [record/field] **OnAfterLoad**=funcname, **OnBeforeSave**=funcname
* [field] **Validator**=methodname - will call `methodname(new_value, [out optional errormsg]) -> bool` to check if a new value is okay to be assigned to this field
	* **OnValidationFail=DontChange|Reset|Abort|...**
	<!--
	* will generate a ValidateFields(callback) function for the class (customizable)
	* `methodname` must be a valid method in the class?
	* how to handle this? Should we also generate a Validate[FieldName] function? What's the callback for?
	* I guess we should call this after serialization (of entire struct or per field?)
	-->

### Container Accessors

* [field] **VectorGetters**=true/element_name - creates Get#At(), Get#Count()
* [field] **VectorSetters**=true/element_name - creates Set#At(), Push#(), Erase#(), Insert#(), Clear#s(), Resize#(), Pop#()
* [field] **MapGetters**- Find#()
* [field] **MapSetters**

### Database Functionality
* [field] **PrimaryKey** - when generating database tables of the parent class, this will be the unique primary key for that table
* [field] **Indexed** - when generating database tables of the parent class, an index on this field will be created for that table
* [record] **CreateTable** - will create a class that acts as an ORM-binding table for this record
* ForeignKey
* indexes on expressions (ala sqlite)

### Hierarchy Functionality
* **Children/ParentPointer/NameInHierarchy** - combine these with a `generic_path` type to create a general hierarchy system (maybe with named hierarchies?)
	Maybe something like a class attribute RClass(Hierarchies=[list, of, hierarchies, ...]) that creates accessors like Get#Parent, Get#Root for each hierarchy
		and if there is only one hierarchy (or Hierarchy=true), the names are simpler

	`RField(Children, ChildPaths=Direct/Named)` - on a child vector; if Direct (default) paths are 'this_object/child_object', if Named, paths are 'this_object/field_name/child_object'

	`RField(Children, Owned)` - on a child vector, has an effect on whether or not the children are fully serialized

	So, for example:

	```c++
	RClass(Hierarchy, Root); /// or Hierarchies=[Game,Location,Object], RootFor=[Game,Location]
	class Game {
		RField(Children, ChildPaths=Named);
		vector<uptr<Location>> Locations;

		RField(Children, ChildPaths=Named);
		vector<uptr<Achievement>> Achievements;
	};

	RClass(Hierarchy); /// or Hierarchies=[Location, Object], RootFor=[Object]
	class Location {
		RField(NameInHierarchy);
		string Name;

		RField(ParentPointer);
		Location* ParentLocation = nullptr;

		RField(Children, ChildPaths=Direct);
		vector<uptr<Object>> Objects;
	};
	```

	or maybe something like RHierarchyRoot(hierarchy_name) + RHierarchyChild(hierarchy_name) + RHierarchyLeaf(hierarchy_name) along with like
	a special templated class that stores hierarchy info?

	Like:

	`RField(HierarchyRoot/Child/Leaf=hierarchy_name);`
	`Reflector::HierarchyRoot<child_vector_type>/HierarchyChild<root_type, sibling_type>/HierarchyLeaf<root_type, sibling_type> hierarchy_name##Data;`
